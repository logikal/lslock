#!/usr/bin/env ruby
require 'rubygems'
require 'bazaar'
require 'optparse'
require 'pp'
require 'fileutils'

options = {}
optparse  = OptionParser.new do |opts|
  opts.banner = 'Usage: lslock <arguments>'
  opts.separator ''
  opts.separator 'Optional Arguments:'
  options[:directory] = '/tmp/lslock-test'
  opts.on('-d', '--directory <path>',
          'the path to look for locked files in') do |directory|
    options[:directory] = directory
  end
end
optparse.parse!

abort('You specified a nonexistent directory!
    You may want to make sure lslock_test is running or that you used the -d flag.
    Run lslock -h for more info') unless File.directory? options[:directory]

# let's start by just getting a listing of items in a directory, and their inodes.
files = Dir.glob("#{options[:directory]}/**")
fileshash = {}
files.each do |file|
  # we need to get the full inode, including device ids
  # otherwise, we're not guaranteed to work on boxes with mutliple disks
  # that seems bad.

  # Hoping this works outside of my test env - major device ids are in hex
  maj = File.stat(file).dev_major.to_s(16)
  min = "%02d" % File.stat(file).dev_minor.to_s(16)
  inode = File.stat(file).ino
  fileshash["#{maj}:#{min}:#{inode}"] = "#{file}"
end

# now let's get the list of locks
# I know awk better.
locks = {}

%x(cat /proc/locks | awk {' print $5 ": " $6'}).lines.each do |line|
  line = line.split(' ')
  locks.merge! "#{line[1]}" => "#{line[0].chomp(':')}"
end

# now we need to actually find the things that have locks in this directory, 
# and pair them up with pids

locks.each do |inode,pid|
  # some locks don't have a file associated with them
  # we don't care about those, just the ones in the directory we care about.
  #
  # Clarity - we're referencing 'inode' here, as the key in the fileshash hash
  if !fileshash[inode].nil? && fileshash[inode].start_with?(options[:directory])
    puts "#{locks[inode]} #{fileshash[inode]}"
  end
end
